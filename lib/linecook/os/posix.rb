# Generated by Linecook

module Linecook
  module Os
    # Defines POSIX-compliant functionality, based on the {IEEE 1003.1-2008
    # standard }[http://pubs.opengroup.org/onlinepubs/9699919799].  See the online
    # documentation for:
    #
    # * {POSIX Shell Command Language
    #   }[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/xcu_chap02.html]
    # * {Special Built-in Utilities
    #   }[http://pubs.opengroup.org/onlinepubs/9699919799/idx/sbi.html]
    # * {Standard Utilties
    #   }[http://pubs.opengroup.org/onlinepubs/9699919799/idx/utilities.html]
    #
    # In addition, the {Shell Hater's Handbook}[http://shellhaters.heroku.com/]
    # provides a nice index of the relevant information.
    #
    module Posix
      require 'linecook/os/posix/command'
      require 'linecook/os/posix/redirect'
      require 'linecook/os/posix/variable'
      require 'linecook/os/posix/utilities'
      include Utilities

      # Returns "$0", the current command name.
      def command_name
        Variable.new(self, 0)
      end

      # Returns the command directory (ie the directory containing $0).
      def command_dir
        "${0%/*}"
      end

      def set_package_dir(dir)
        export var('LINECOOK_PACKAGE_DIR', dir)
      end

      # Returns an expression that evaluates to the package dir.
      def package_dir
        '${LINECOOK_PACKAGE_DIR:-$PWD}'
      end

      def target_path(target_name)
        File.join(package_dir, target_name)
      end

      # A hash of functions defined for self.
      def functions
        @functions ||= {}
      end

      # Defines a function from the block.  The block content is indented and
      # cleaned up some to make a nice function definition.
      def function(name, method_name=name)
        str = capture { indent { yield(*signature(Proc.new.arity)) } }.to_s
        function = %{#{name}() {\n#{str.chomp("\n")}\n}}
        
        if function?(name)
          unless functions[name] == function
            Kernel.raise "function already defined: #{name.inspect}"
          end
        else
          functions[name] = function
          
          if method_name
            instance_eval %{
              def self.#{method_name}(*args)
                execute '#{method_name}', *args
              end
            }
          end
        end
        
        writeln function
        name
      end

      # Returns true if a function with the given name is defined.
      def function?(name)
        functions.has_key?(name)
      end

      # Returns an array of positional variables for use as inputs to a function
      # block.  Splat blocks are supported; the splat expression behaves like $*.
      def signature(arity)
        variables = Array.new(arity.abs) {|i| Variable.new(self, i+1) }
        
        if arity < 0
          # This works for defaults...
          # $(shift 1; echo ${*:-NONE})
          # You can't do this:
          # ${$(shift 1; echo $*):-NONE}
          variables[-1] = "$(shift #{arity.abs - 1}; echo $*)"
        end
        
        variables
      end

      # Set a variable.
      def var(name, value=nil)
        if Kernel.block_given?
          if value.nil?
            value = "$(\n#{capture(&Proc.new).to_s.strip}\n)"
          else
            Kernel.raise "value and block cannot both be specified"
          end
        end

        var = Variable.new(self, name)

        unless value.nil?
          var.value = value
        end

        var 
      end

      def trailer
        /(\s*(?:\ncheck_status.*?\n\s*)?)\z/
      end

      # Adds a redirect to append stdout to a file.
      def append(path=nil)
        redirect(nil, path || '/dev/null', '>>')
      end

      def _append(*args, &block) # :nodoc:
        str = capture { append(*args, &block) }.to_s
        str.strip!
        str
      end

      # Exit from for, while, or until loop.
      # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_15]
      def break_()
        #  break
        #  
        write "break\n"

      end

      def _break_(*args, &block) # :nodoc:
        str = capture { break_(*args, &block) }.to_s
        str.strip!
        str
      end

      # Adds a check that ensures the last exit status is as indicated. Note that no
      # check will be added unless check_status_function is added beforehand.
      def check_status(expect_status=0, fail_status='$?')
        #  <% if function?('check_status') %>
        #  check_status <%= expect_status %> $? <%= fail_status %> $LINENO
        #  
        #  <% end %>
        if function?('check_status') 
        write "check_status "; write(( expect_status ).to_s); write " $? "; write(( fail_status ).to_s); write " $LINENO\n"
        ; write "\n"
        ;  end 
      end

      def _check_status(*args, &block) # :nodoc:
        str = capture { check_status(*args, &block) }.to_s
        str.strip!
        str
      end

      # Defines the check status function.
      def check_status_function()
        function('check_status', nil) do |expected, actual, error, message|
          message.default = '?'
          
          if_ actual.ne(expected) do
            writeln %{echo [#{actual}] #{command_name}:#{message}}
            exit_ error
          end
          
          else_ do
            return_ actual
          end
        end
      end

      def _check_status_function(*args, &block) # :nodoc:
        str = capture { check_status_function(*args, &block) }.to_s
        str.strip!
        str
      end

      # Writes a comment.
      def comment(str)
        #  # <%= str %>
        #  
        write "# "; write(( str ).to_s); write "\n"

      end

      def _comment(*args, &block) # :nodoc:
        str = capture { comment(*args, &block) }.to_s
        str.strip!
        str
      end

      # Continue for, while, or until loop.
      # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_17]
      def continue_()
        #  continue
        #  
        write "continue\n"

      end

      def _continue_(*args, &block) # :nodoc:
        str = capture { continue_(*args, &block) }.to_s
        str.strip!
        str
      end

      # Chains to if_ to make an else-if statement.
      def elif_(expression)
        unless match = _rewrite_(/(\s+)(fi\s*)/)
          Kernel.raise "elif_ used outside of if_ statement"
        end
        #  <%= match[1] %>
        #  elif <%= expression %>
        #  then
        #  <% indent { yield } %>
        #  <%= match[2] %>
        write(( match[1] ).to_s)
        write "elif "; write(( expression ).to_s); write "\n"
        ; write "then\n"
        ;  indent { yield } 
        write(( match[2] ).to_s)
      end

      def _elif_(*args, &block) # :nodoc:
        str = capture { elif_(*args, &block) }.to_s
        str.strip!
        str
      end

      # Chains to if_ or unless_ to make an else statement.
      def else_()
        unless match = _rewrite_(/(\s+)(fi\s*)/)
          Kernel.raise "else_ used outside of if_ statement"
        end
        #  <%= match[1] %>
        #  else
        #  <% indent { yield } %>
        #  <%= match[2] %>
        write(( match[1] ).to_s)
        write "else\n"
        ;  indent { yield } 
        write(( match[2] ).to_s)
      end

      def _else_(*args, &block) # :nodoc:
        str = capture { else_(*args, &block) }.to_s
        str.strip!
        str
      end

      # Executes a command and checks the output status. Quotes all non-option args
      # that aren't already quoted. Accepts a trailing hash which will be transformed
      # into command line options.
      def execute(command, *args)
        if chain?
          write " | "
        else
          doc.append_line
        end

        args = args.compact
        options = args.last.kind_of?(Hash) ? args.pop : {}
        Command.new(command, args, options).write_to doc

        chain_proxy
      end

      def _execute(*args, &block) # :nodoc:
        str = capture { execute(*args, &block) }.to_s
        str.strip!
        str
      end

      # Cause the shell to exit.
      # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_21]
      def exit_(status=nil)
        #  <% if status.nil? %>
        #  exit
        #  <% else %>
        #  exit <%= status %>
        #  <% end %>
        #  
        if status.nil? 
        write "exit\n"
        ;  else 
        write "exit "; write(( status ).to_s); write "\n"
        ;  end 

      end

      def _exit_(*args, &block) # :nodoc:
        str = capture { exit_(*args, &block) }.to_s
        str.strip!
        str
      end

      # Assigns stdin to the file.
      def from(path)
        redirect(nil, path, '<')
      end

      def _from(*args, &block) # :nodoc:
        str = capture { from(*args, &block) }.to_s
        str.strip!
        str
      end

      # Makes a heredoc statement surrounding the contents of the block.  Options:
      # 
      #   delimiter   the delimiter used, by default HEREDOC_n where n increments
      #   outdent     add '-' before the delimiter
      #   quote       quotes the delimiter
      def heredoc(options={})
        unless options.kind_of?(Hash)
          options = {:delimiter => options}
        end
        outdent = options[:outdent] ? '-' : ' '
        delimiter = options[:delimiter] || begin
          @heredoc_count ||= -1
          "HEREDOC_#{@heredoc_count += 1}"
        end

        Redirect.new(self) do
          write "<<#{outdent}#{options[:quote] ? "\"#{delimiter}\"" : delimiter}"
          outdent(" # :#{delimiter}:") do
            writeln
            yield
            write delimiter
          end
          writeln
        end
      end

      def _heredoc(*args, &block) # :nodoc:
        str = capture { heredoc(*args, &block) }.to_s
        str.strip!
        str
      end

      # Executes the block when the expression evaluates to zero.
      def if_(expression)
        #  if <%= expression.to_s.chomp("\n") %>
        #  then
        #  <% indent { yield } %>
        #  fi
        #  
        #  
        write "if "; write(( expression.to_s.chomp("\n") ).to_s); write "\n"
        ; write "then\n"
        ;  indent { yield } 
        write "fi\n"
        ; write "\n"

      end

      def _if_(*args, &block) # :nodoc:
        str = capture { if_(*args, &block) }.to_s
        str.strip!
        str
      end

      # Makes a redirect statement.
      def redirect(source, target, redirection='>')
        if chain?
          write " "
        end

        Redirect.new(source, target, redirection).write_to doc
        chain_proxy
      end

      def _redirect(*args, &block) # :nodoc:
        str = capture { redirect(*args, &block) }.to_s
        str.strip!
        str
      end

      # Return from a function.
      # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_24]
      def return_(status=nil)
        #  <% if status.nil? %>
        #  return
        #  <% else %>
        #  return <%= status %>
        #  <% end %>
        #  
        if status.nil? 
        write "return\n"
        ;  else 
        write "return "; write(( status ).to_s); write "\n"
        ;  end 

      end

      def _return_(*args, &block) # :nodoc:
        str = capture { return_(*args, &block) }.to_s
        str.strip!
        str
      end

      # Write a comment to delimit sections.  The comment takes the format:
      # 
      #   #### name ###
      def section(name="")
        n = (78 - name.length)/2
        str = "-" * n
        #  #<%= str %><%= name %><%= str %><%= "-" if name.length % 2 == 1 %>
        #  
        write "#"; write(( str ).to_s); write(( name ).to_s); write(( str ).to_s); write(( "-" if name.length % 2 == 1 ).to_s); write "\n"

      end

      def _section(*args, &block) # :nodoc:
        str = capture { section(*args, &block) }.to_s
        str.strip!
        str
      end

      def test(expression)
        #  [ <%= expression %> ]
        #  
        write "[ "; write(( expression ).to_s); write " ]\n"

      end

      def _test(*args, &block) # :nodoc:
        str = capture { test(*args, &block) }.to_s
        str.strip!
        str
      end

      # Adds a redirect of stdout to a file.
      def to(path=nil)
        redirect(nil, path || '/dev/null')
      end

      def _to(*args, &block) # :nodoc:
        str = capture { to(*args, &block) }.to_s
        str.strip!
        str
      end

      # Executes the block when the expression evaluates to a non-zero value.
      def unless_(expression)
        if_("! #{expression}") { yield }
      end

      def _unless_(*args, &block) # :nodoc:
        str = capture { unless_(*args, &block) }.to_s
        str.strip!
        str
      end

      # Executes the block until the expression evaluates to zero.
      def until_(expression)
        #  until <%= expression.to_s.chomp("\n") %>
        #  do
        #  <% indent { yield } %>
        #  done
        #  
        #  
        write "until "; write(( expression.to_s.chomp("\n") ).to_s); write "\n"
        ; write "do\n"
        ;  indent { yield } 
        write "done\n"
        ; write "\n"

      end

      def _until_(*args, &block) # :nodoc:
        str = capture { until_(*args, &block) }.to_s
        str.strip!
        str
      end

      # Executes the block while the expression evaluates to zero.
      def while_(expression)
        #  while <%= expression.to_s.chomp("\n") %>
        #  do
        #  <% indent { yield } %>
        #  done
        #  
        #  
        write "while "; write(( expression.to_s.chomp("\n") ).to_s); write "\n"
        ; write "do\n"
        ;  indent { yield } 
        write "done\n"
        ; write "\n"

      end

      def _while_(*args, &block) # :nodoc:
        str = capture { while_(*args, &block) }.to_s
        str.strip!
        str
      end
    end
  end
end
